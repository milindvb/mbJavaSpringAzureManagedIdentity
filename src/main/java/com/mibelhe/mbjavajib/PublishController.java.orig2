package com.mibelhe.mbjavajib;

import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import com.microsoft.azure.AzureEnvironment;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import com.microsoft.azure.credentials.AppServiceMSICredentials;

import com.microsoft.azure.keyvault.KeyVaultClient;
import com.microsoft.azure.keyvault.models.KeyBundle;

import java.util.HashMap;

import java.util.Map;

import java.util.Optional;



import org.springframework.core.env.ConfigurableEnvironment;

import org.springframework.core.env.MutablePropertySources;

import org.springframework.core.env.StandardEnvironment;

import org.springframework.core.io.DefaultResourceLoader;

import org.springframework.core.io.Resource;

import org.springframework.util.Assert;

import org.springframework.util.ClassUtils;



import java.util.HashMap;

import java.util.Map;

import java.util.Optional;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import com.google.gson.Gson;

import com.google.gson.GsonBuilder;

//import com.microsoft.azure.eventhubs.AzureActiveDirectoryTokenProvider;

import com.microsoft.azure.eventhubs.ConnectionStringBuilder;

import com.microsoft.azure.eventhubs.EventData;

import com.microsoft.azure.eventhubs.EventHubClient;

import com.microsoft.azure.eventhubs.EventHubException;

import com.microsoft.azure.eventhubs.EventPosition;

import com.microsoft.azure.eventhubs.PartitionReceiver;



import java.io.IOException;

import java.net.URISyntaxException;

import java.nio.charset.Charset;

import java.time.Instant;

import java.util.concurrent.ExecutionException;

import java.util.concurrent.Executors;

import java.util.concurrent.ScheduledExecutorService;

//import com.azure.messaging.eventhubs.*;
import static java.nio.charset.StandardCharsets.UTF_8;
import com.azure.messaging.eventhubs.models.CreateBatchOptions;
import com.azure.messaging.eventhubs.models.EventPosition;
import com.azure.messaging.eventhubs.models.PartitionEvent;


@RestController
public class PublishController {

	@RequestMapping(value = "/publishMessage", method = RequestMethod.GET)

	public String message(@RequestBody String name){
            return name;
	}

        @RequestMapping(value="/hello")
        @ResponseBody

        public String method9(@RequestParam("text") String txt) throws EventHubException, ExecutionException, InterruptedException, IOException {

           String msiEndpoint =  System.getenv("MSI_ENDPOINT");
           String msiSecret =  System.getenv("MSI_SECRET");
           AppServiceMSICredentials msiCredentials = new AppServiceMSICredentials(AzureEnvironment.AZURE,msiEndpoint, msiSecret);
           //msiCredentials.withClientId("0f3537eb-97be-4993-b3be-f67971a019e7");
           KeyVaultClient keyVaultClient = new KeyVaultClient(msiCredentials);
           String secret = keyVaultClient.getSecret("https://mbkey.vault.azure.net/","MB-TEST-SECRET").toString();
           String key = keyVaultClient.getKey("https://mbkey.vault.azure.net/","mbappkey").toString();
/*
           final ConnectionStringBuilder connStr = new ConnectionStringBuilder()
                .setNamespaceName("mbeventhub1")
                //.setEndpoint("sb://mbeventhub1.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=7ih0ZlfGTyaG1B9NPlbmf9BO4Hklo0DjKyPk23rGVPI=")
                .setEventHubName("eventhub1")
                .setAuthentication(ConnectionStringBuilder.MANAGED_IDENTITY_AUTHENTICATION);


   	   final Gson gson = new GsonBuilder().create();

			// The Executor handles all asynchronous tasks and this is passed to the EventHubClient instance.
			// This enables the user to segregate their thread pool based on the work load.
			// This pool can then be shared across multiple EventHubClient instances.
			// The following sample uses a single thread executor, as there is only one EventHubClient instance,
			// handling different flavors of ingestion to Event Hubs here.
	   final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(4);

			// Each EventHubClient instance spins up a new TCP/SSL connection, which is expensive.
			// It is always a best practice to reuse these instances. The following sample shows this.
	   final EventHubClient ehClient = EventHubClient.createFromConnectionStringSync(connStr.toString(), executorService);


	   try {
		for (int i = 0; i < 10; i++) {

			String payload = "Message " + Integer.toString(i);
			byte[] payloadBytes = gson.toJson(payload).getBytes(Charset.defaultCharset());
			EventData sendEvent = EventData.create(payloadBytes);
					// Send - not tied to any partition
					// Event Hubs service will round-robin the events across all Event Hubs partitions.
					// This is the recommended & most reliable way to send to Event Hubs.
			ehClient.sendSync(sendEvent);
		}

		//System.out.println(Instant.now() + ": Send Complete...");
		//System.out.println("Press Enter to stop.");
		//System.in.read();
            } finally {
		ehClient.closeSync();
		executorService.shutdown();
	    }
*/
           final String connectionString = "sb://mbeventhub1.servicebus.windows.net/";
           final String eventHubName = "eventhub1";
           EventHubProducerClient producer = new EventHubClientBuilder()
              .connectionString(connectionString, eventHubName)
              .buildProducerClient();
        // prepare a batch of events to send to the event hub    
           //CreateBatchOptions options = new CreateBatchOptions().setPartitionId("foo");
           EventDataBatch batch = producer.createBatch();
           batch.tryAdd(new EventData("First event"));
           batch.tryAdd(new EventData("Second event"));
           batch.tryAdd(new EventData("Third event"));
           batch.tryAdd(new EventData("Fourth event"));
           batch.tryAdd(new EventData("Fifth event"));

        // send the batch of events to the event hub
           producer.send(batch);
 
        // close the producer
           producer.close();	


           return "key: "+key;

        }

}

